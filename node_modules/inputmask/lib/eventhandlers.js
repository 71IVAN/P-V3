import {
    caret, determineNewCaretPosition,
    getBuffer, getBufferTemplate,
    getLastValidPosition, isMask,
    resetMaskSet,
    seekNext,
    seekPrevious,
    translatePosition
} from "./positioning";
import {keys} from "./keycode.js";
import {iphone, mobile} from "./environment";
import {handleRemove, isComplete, isSelection, isValid} from "./validation";
import {applyInputValue, checkVal, clearOptionalTail, HandleNativePlaceholder, writeBuffer} from "./inputHandling";
import {getPlaceholder, getTest} from "./validation-tests";

export {EventHandlers};

var EventHandlers = {
    keyEvent: function (e, checkval, writeOut, strict, ndx) {
        const inputmask = this.inputmask, opts = inputmask.opts, $ = inputmask.dependencyLib,
            maskset = inputmask.maskset;

        var input = this,
            $input = $(input),
            c = e.key,
            pos = caret.call(inputmask, input);

        var kdResult = opts.onKeyDown.call(this, e, getBuffer.call(inputmask), pos, opts);
        if (kdResult !== undefined) return kdResult;

        //backspace, delete, and escape get special treatment
        if (c === keys.Backspace || c === keys.Delete || (iphone && c === keys.BACKSPACE_SAFARI) || (e.ctrlKey && c === keys.x && !("oncut" in input))) { //backspace/delete
            e.preventDefault(); //stop default action but allow propagation
            handleRemove.call(inputmask, input, c, pos);
            writeBuffer(input, getBuffer.call(inputmask, true), maskset.p, e, input.inputmask._valueGet() !== getBuffer.call(inputmask).join(""));
        } else if (c === keys.End || c === keys.PageDown) { //when END or PAGE_DOWN pressed set position at lastmatch
            e.preventDefault();
            var caretPos = seekNext.call(inputmask, getLastValidPosition.call(inputmask));
            caret.call(inputmask, input, e.shiftKey ? pos.begin : caretPos, caretPos, true);
        } else if ((c === keys.Home && !e.shiftKey) || c === keys.PageUp) { //Home or page_up
            e.preventDefault();
            caret.call(inputmask, input, 0, e.shiftKey ? pos.begin : 0, true);
        } else if (((opts.undoOnEscape && c === keys.Escape) || (false && c === keys.z && e.ctrlKey)) && e.altKey !== true) { //escape && undo && #762
            checkVal(input, true, false, inputmask.undoValue.split(""));
            $input.trigger("click");
        } else if (c === keys.Insert && !(e.shiftKey || e.ctrlKey) && inputmask.userOptions.insertMode === undefined) { //insert
            if (!isSelection.call(inputmask, pos)) {
                opts.insertMode = !opts.insertMode;
                caret.call(inputmask, input, pos.begin, pos.begin);
            } else opts.insertMode = !opts.insertMode;
        } else if (opts.tabThrough === true && c === keys.Tab) {
            if (e.shiftKey === true) {
                pos.end = seekPrevious.call(inputmask, pos.end, true);
                if (getTest.call(inputmask, pos.end - 1).match.static === true) {
                    pos.end--;
                }
                pos.begin = seekPrevious.call(inputmask, pos.end, true);
                if (pos.begin >= 0 && pos.end > 0) {
                    e.preventDefault();
                    caret.call(inputmask, input, pos.begin, pos.end);
                }
            } else {
                pos.begin = seekNext.call(inputmask, pos.begin, true);
                pos.end = seekNext.call(inputmask, pos.begin, true);
                if (pos.end < maskset.maskLength) pos.end--;
                if (pos.begin <= maskset.maskLength) {
                    e.preventDefault();
                    caret.call(inputmask, input, pos.begin, pos.end);
                }
            }
        } else if (